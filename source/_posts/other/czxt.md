---
title: 操作系统
toc: true
date: 2021-09-06 10:58:17
# thumbnail: /images/2021/岁月的童话2.jpg7.1.1
tags:
  - other
  - blog
categories:
  - other

---

- [引论](#引论)
  - [1 引论](#1-引论)
- [二 进程管理](#二-进程管理)
  - [2 进程管理](#2-进程管理)
  - [2.1.4程序的三态](#214程序的三态)
    - [2.1.5](#215)
    - [2.3.1.4 同步机制应遵循的规则](#2314-同步机制应遵循的规则)
    - [2.3.2 信号量机制](#232-信号量机制)
    - [2.3.3 信号量的应用](#233-信号量的应用)
    - [2.6.4 线程的实现](#264-线程的实现)
- [三 处理机调度与死锁](#三-处理机调度与死锁)
  - [3.3 调 度 算 法](#33-调-度-算-法)
    - [3.2.1 先来先服务和短作业(进程)优先调度算法](#321-先来先服务和短作业进程优先调度算法)
    - [3.3.2 高优先权优先调度算法](#332-高优先权优先调度算法)
    - [3.5.2 产生死锁的必要条件](#352-产生死锁的必要条件)
    - [3.5.3 处理死锁的基本方法](#353-处理死锁的基本方法)
- [第四章 存 储 器 管 理](#第四章-存-储-器-管-理)
  - [。。。](#)
    - [4.3.3 动态分区分配](#433-动态分区分配)

<!--more-->
# 引论

## 1 引论

----

# 二 进程管理


## 2 进程管理

## 2.1.4程序的三态

- 就绪态
- 执行状态
- 阻塞状态


### 2.1.5

> PCB (PROCESS CONTROL BLOCK) 


### 2.3.1.4 同步机制应遵循的规则

- 空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源
- 忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。
- 有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态
- 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。

> 让权等待可以对比循环查询，和队列触发这两者比较。前者永远在不停的检测是否可以使用，后者则是通过事件，当任务执行完毕后自动调用阻塞的任务。

### 2.3.2 信号量机制

- P 通过
- V 释放
- wait()
- signl()

### 2.3.3 信号量的应用
- 1．利用信号量实现进程互
- 2．利用信号量实现前趋关系
  
### 2.6.4 线程的实现

用户级线程与内核控制线程的连接
- 1v1
- nv1
- nvn

# 三 处理机调度与死锁

## 3.3 调 度 算 法
### 3.2.1 先来先服务和短作业(进程)优先调度算法
- 先来先服务
- 短作业优先 
  - 饥饿
  
### 3.3.2 高优先权优先调度算法
### 3.5.2 产生死锁的必要条件
- 互斥条件
- 请求和保持条件
- 不剥夺条件
- 环路等待条件
### 3.5.3 处理死锁的基本方法
- 预防死锁
- 避免死锁
- 检测死锁
- 解除死锁

# 第四章 存 储 器 管 理
## 。。。
### 4.3.3 动态分区分配
 分区分配中的数据结构
- 空闲分区表
- 空闲分区链

 分区分配算法
- 首次适应算法(first fit) 
  - 求空闲分区链以地址递增的次序链接，分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。
- 循环首次适应算法(next fit)
  - 不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区。
- 最佳适应算法(best fit)
  - 把能满足要求、又是最小的空闲分区分配给作业
- 最坏适应算法(worst fit) 
  - 最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用
- 快速适应算法(quick fit)

> 碎片 内/外碎片  整体无法使用的的块儿（外部），和分配块儿后，块儿内无法使用的部分（内部）。